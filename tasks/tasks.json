{
  "tasks": [
    {
      "id": 1,
      "title": "Set up project structure and configuration",
      "description": "Create the initial project structure following Domain-Driven Design architecture and implement configuration loading from environment variables.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "1. Create project directory structure with domain, application, infrastructure, and interface layers\n2. Implement Settings class to load configuration from environment variables\n3. Set up logging configuration\n4. Create directory initialization for output and logs\n5. Configure rate limiters for GitHub and LLM APIs\n6. Implement basic error handling utilities\n7. Set up project dependencies and requirements.txt",
      "testStrategy": "Verify configuration loading with different environment variables. Test directory creation logic. Ensure rate limiter configurations are correctly applied. Validate error handling utilities with mock errors.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create DDD project directory structure",
          "description": "Set up the initial project directory structure following Domain-Driven Design architecture principles with separate layers for domain, application, infrastructure, and interface.",
          "dependencies": [],
          "details": "1. Create the root project directory\n2. Create subdirectories for each DDD layer:\n   - `domain/`: Core business logic and entities\n   - `application/`: Use cases and application services\n   - `infrastructure/`: External services, repositories, and technical concerns\n   - `interface/`: API endpoints, CLI, or UI components\n3. Add `__init__.py` files to make directories importable Python packages\n4. Create a basic README.md with project overview\n5. Test by verifying all directories exist and are properly structured\n\n<info added on 2025-04-27T23:13:42.047Z>\n# Implementation Details for DDD Structure\n\n## Specific Directory Structure\n```\nsrc/repo_organizer/\n├── domain/\n│   ├── __init__.py\n│   ├── entities/\n│   │   └── __init__.py\n│   ├── value_objects/\n│   │   └── __init__.py\n│   ├── repositories/\n│   │   └── __init__.py\n│   └── services/\n│       └── __init__.py\n├── application/\n│   ├── __init__.py\n│   ├── use_cases/\n│   │   └── __init__.py\n│   ├── services/\n│   │   └── __init__.py\n│   └── dtos/\n│       └── __init__.py\n├── infrastructure/\n│   ├── __init__.py\n│   ├── repositories/\n│   │   └── __init__.py\n│   ├── external_services/\n│   │   └── __init__.py\n│   └── persistence/\n│       └── __init__.py\n└── interface/\n    ├── __init__.py\n    ├── cli/\n    │   └── __init__.py\n    ├── api/\n    │   └── __init__.py\n    └── views/\n        └── __init__.py\n```\n\n## Layer Responsibility Documentation\nCreate a `ARCHITECTURE.md` file explaining:\n- **Domain Layer**: Contains business entities (Repository, File, Commit), value objects (FileType, Path), domain services, and repository interfaces\n- **Application Layer**: Contains use cases (OrganizeRepository, AnalyzeCodebase), application services, and DTOs for data transfer\n- **Infrastructure Layer**: Contains repository implementations, GitHub/GitLab API clients, file system access\n- **Interface Layer**: Contains CLI commands, API controllers, and view models\n\n## Implementation Notes\n- Use absolute imports (e.g., `from repo_organizer.domain.entities import Repository`)\n- Add `__all__` lists in `__init__.py` files to control exported symbols\n- Create empty placeholder files (e.g., `.gitkeep`) in directories that will be populated later\n- Consider adding a simple dependency injection container in the infrastructure layer\n\n## Verification Script\n```python\nimport os\nimport sys\n\ndef verify_structure(base_path):\n    \"\"\"Verify the DDD directory structure exists correctly\"\"\"\n    required_dirs = [\n        \"domain\", \"domain/entities\", \"domain/value_objects\",\n        \"application\", \"application/use_cases\",\n        \"infrastructure\", \"infrastructure/repositories\",\n        \"interface\", \"interface/cli\"\n    ]\n    \n    for dir_path in required_dirs:\n        full_path = os.path.join(base_path, dir_path)\n        if not os.path.exists(full_path):\n            print(f\"ERROR: Missing directory {full_path}\")\n            return False\n        \n        init_file = os.path.join(full_path, \"__init__.py\")\n        if not os.path.exists(init_file):\n            print(f\"ERROR: Missing __init__.py in {full_path}\")\n            return False\n    \n    print(\"✅ Directory structure verified successfully\")\n    return True\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1:\n        base_path = sys.argv[1]\n    else:\n        base_path = \"src/repo_organizer\"\n    \n    verify_structure(base_path)\n```\n</info added on 2025-04-27T23:13:42.047Z>\n\n<info added on 2025-04-28T00:10:01.885Z>\n# Implementation Plan for Subtask 1.1: Create DDD Project Directory Structure\n\n## 1. Review Existing Structure\n- The current workspace already contains a `src/repo_organizer/` directory with subfolders: `domain/`, `application/`, `infrastructure/`, `interface/`, and their respective submodules (e.g., `core/`, `analysis/`, `source_control/`, `cli/`).\n- I will compare the actual structure to the planned DDD structure to ensure all required directories and `__init__.py` files exist.\n\n## 2. Planned Actions\n- Verify and, if needed, create the following directories and files:\n  - `src/repo_organizer/domain/` with subfolders: `entities/`, `value_objects/`, `repositories/`, `services/`\n  - `src/repo_organizer/application/` with subfolders: `use_cases/`, `services/`, `dtos/`\n  - `src/repo_organizer/infrastructure/` with subfolders: `repositories/`, `external_services/`, `persistence/`\n  - `src/repo_organizer/interface/` with subfolders: `cli/`, `api/`, `views/`\n- Ensure each directory contains an `__init__.py` file (create if missing).\n- Add `.gitkeep` files to empty directories for version control.\n- Add or update `ARCHITECTURE.md` to document layer responsibilities.\n- Add or update a verification script to check the structure.\n\n## 3. Reasoning\n- This ensures the project adheres to DDD principles and is ready for further development.\n- Having all `__init__.py` files allows for proper Python imports.\n- Documenting the architecture helps onboard new contributors and clarifies design intent.\n\n## 4. Potential Challenges\n- Some subfolders may already exist with different names (e.g., `core/` instead of `entities/`).\n- Need to avoid overwriting existing files or removing custom code.\n- Will log any discrepancies and resolve them as needed.\n\n## 5. Next Steps\n- Run the verification script after making changes to confirm the structure is correct.\n- Mark this subtask as done once the structure matches the plan and is verified.\n</info added on 2025-04-28T00:10:01.885Z>",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 2,
          "title": "Implement Settings class for configuration management",
          "description": "Create a Settings class that loads and manages configuration from environment variables with appropriate defaults and validation.",
          "dependencies": [
            1
          ],
          "details": "1. Create `infrastructure/config/settings.py`\n2. Implement a Settings class using Pydantic BaseSettings\n3. Define configuration fields with appropriate types and default values\n4. Add validation for required fields\n5. Implement environment variable loading with proper prefixes\n6. Add documentation for each configuration option\n7. Test by creating a sample .env file and verifying settings are loaded correctly\n\n<info added on 2025-04-28T00:21:41.895Z>\n# Implementation Details for Settings Class\n\n## Code Structure\n```python\nfrom pydantic import BaseSettings, Field, validator\nfrom typing import Optional, List\nimport os\n\nclass Settings(BaseSettings):\n    # GitHub API configuration\n    github_token: str = Field(..., description=\"GitHub Personal Access Token\")\n    github_username: Optional[str] = Field(None, description=\"GitHub username for API requests\")\n    \n    # Application settings\n    log_level: str = Field(\"INFO\", description=\"Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\")\n    cache_dir: str = Field(\"~/.repo_organizer/cache\", description=\"Directory for caching data\")\n    max_repos: int = Field(100, description=\"Maximum number of repositories to process\")\n    \n    # Feature flags\n    enable_analytics: bool = Field(False, description=\"Enable usage analytics\")\n    debug_mode: bool = Field(False, description=\"Enable debug mode with additional logging\")\n    \n    @validator('github_token')\n    def validate_github_token(cls, v):\n        if not v or len(v) < 10:\n            raise ValueError(\"GitHub token is required and must be valid\")\n        return v\n    \n    class Config:\n        env_prefix = \"REPO_ORGANIZER_\"\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n        case_sensitive = False\n```\n\n## Usage Example\n```python\n# Example usage in application\nfrom infrastructure.config.settings import Settings\n\ndef initialize_app():\n    settings = Settings()\n    print(f\"Using GitHub token: {settings.github_token[:4]}...\")\n    print(f\"Cache directory: {settings.cache_dir}\")\n    return settings\n\n# Access settings throughout the application\nsettings = initialize_app()\n```\n\n## Testing Strategy\n1. Create a test file with different environment configurations\n2. Test missing required fields (should raise validation errors)\n3. Test default values when not specified\n4. Test environment variable overrides\n5. Test .env file loading\n\n## Error Handling\n- Add custom error messages for common configuration issues\n- Implement a configuration validation function that can be called at startup\n- Consider adding a `get_settings()` factory function for dependency injection in FastAPI\n</info added on 2025-04-28T00:21:41.895Z>",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 3,
          "title": "Set up logging configuration and directory initialization",
          "description": "Configure the logging system and implement automatic creation of required directories for logs and output files.",
          "dependencies": [
            2
          ],
          "details": "1. Create `infrastructure/logging/logger.py`\n2. Configure logging with different levels (DEBUG, INFO, ERROR)\n3. Set up log formatting with timestamps and log levels\n4. Implement file and console handlers\n5. Create a function to initialize required directories (logs/, output/)\n6. Add error handling for directory creation\n7. Test by writing logs to both console and file, verifying directories are created",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 4,
          "title": "Implement rate limiters for external APIs",
          "description": "Create rate limiting utilities for GitHub and LLM APIs to prevent exceeding usage limits.",
          "dependencies": [
            2,
            3
          ],
          "details": "1. Create `infrastructure/rate_limiting/` directory\n2. Implement a base RateLimiter class with configurable limits\n3. Create specific implementations for GitHub API (GitHubRateLimiter)\n4. Create specific implementations for LLM API (LLMRateLimiter)\n5. Add retry logic with exponential backoff\n6. Implement rate limit tracking and persistence\n7. Test by simulating rapid API calls and verifying rate limiting behavior",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 5,
          "title": "Set up error handling and project dependencies",
          "description": "Implement error handling utilities and define project dependencies in requirements.txt.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. Create `infrastructure/errors/` directory\n2. Implement custom exception classes for different error types\n3. Create error handling utilities (try-except wrappers, error loggers)\n4. Create requirements.txt with all necessary dependencies and version constraints\n5. Add setup.py for package installation\n6. Document installation process in README.md\n7. Test by installing dependencies in a fresh virtual environment and verifying error handling works",
          "status": "done",
          "parentTaskId": 1
        }
      ]
    },
    {
      "id": 2,
      "title": "Implement GitHub API integration",
      "description": "Create a GitHub REST API adapter to fetch repository data including metadata, languages, commit history, and contributor information.",
      "status": "pending",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "1. Create GitHubService in the infrastructure layer\n2. Implement authentication with GitHub token\n3. Create methods to fetch repository metadata, languages, commits, and contributors\n4. Implement rate limiting with configurable limits (default: 30 calls/minute)\n5. Add retry mechanism with exponential backoff\n6. Create data transformation from GitHub API responses to domain models\n7. Implement error handling for API failures",
      "testStrategy": "Test with mock GitHub API responses. Verify authentication process. Validate rate limiting behavior. Ensure proper transformation of API responses to domain models. Test retry mechanism with simulated failures."
    },
    {
      "id": 3,
      "title": "Create LangChain Claude AI integration",
      "description": "Implement the LangChain Claude Adapter for AI-powered repository analysis with extended thinking capabilities.",
      "status": "pending",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "1. Create LangChainClaudeAdapter in the infrastructure layer\n2. Implement authentication with Anthropic API key\n3. Design analysis prompts for repository evaluation\n4. Implement extended thinking capabilities with configurable token budget\n5. Create response parsing for structured output\n6. Add rate limiting (default: 10 calls/minute)\n7. Implement error handling and fallback mechanisms\n8. Configure temperature and other LLM parameters",
      "testStrategy": "Test with mock LLM responses. Verify prompt construction. Validate response parsing with sample outputs. Test rate limiting behavior. Ensure error handling works correctly with simulated API failures."
    },
    {
      "id": 4,
      "title": "Develop core domain models and services",
      "description": "Create the domain models and services for repository analysis and action recommendations following DDD principles.",
      "status": "pending",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "1. Create Repository domain model with metadata, languages, commits, and contributors\n2. Implement RepoAnalysis domain model with strengths, weaknesses, and recommendations\n3. Create AnalysisService for determining repository value and activity\n4. Implement ActionRecommendationService for generating DELETE/ARCHIVE/EXTRACT/KEEP/PIN recommendations\n5. Define interfaces/protocols for infrastructure adapters\n6. Create value objects for recommendations, actions, and assessment results\n7. Implement domain events for significant state changes",
      "testStrategy": "Unit test domain models with various data scenarios. Verify action recommendation logic with different repository characteristics. Test domain services with mock dependencies. Ensure protocols are properly defined with required methods."
    },
    {
      "id": 5,
      "title": "Implement application layer orchestration",
      "description": "Create the application layer to orchestrate the repository analysis process and coordinate between domain services.",
      "status": "pending",
      "dependencies": [
        2,
        3,
        4
      ],
      "priority": "high",
      "details": "1. Create ApplicationRunner to coordinate the analysis process\n2. Implement AnalyzeRepositoriesUseCase to connect source control with analysis\n3. Create ApplicationFactory for dependency injection\n4. Implement progress tracking and reporting\n5. Add cross-cutting concerns like error handling\n6. Create caching mechanism for previously analyzed repositories\n7. Implement report generation coordination",
      "testStrategy": "Test application runner with mock domain services. Verify use case execution flow. Test progress tracking with different repository counts. Validate caching mechanism with repeated analysis requests. Ensure proper error propagation and handling."
    },
    {
      "id": 6,
      "title": "Create CLI interface with Typer and Rich",
      "description": "Implement the command-line interface with rich formatting for user interaction and progress visualization.",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "1. Set up Typer CLI application structure\n2. Implement 'analyze' command with options for repository selection and analysis\n3. Create 'cleanup' command for housekeeping\n4. Implement progress visualization using Rich library\n5. Add color coding for different actions and outputs\n6. Create help documentation for commands\n7. Implement command-line argument parsing\n8. Add environment variable handling for configuration",
      "testStrategy": "Test CLI commands with mock application layer. Verify command-line argument parsing. Test progress visualization with different repository counts. Ensure help documentation is complete and accurate. Validate environment variable handling."
    },
    {
      "id": 7,
      "title": "Implement repository analysis reporting",
      "description": "Create the reporting system to generate individual repository reports and summary reports with categorization.",
      "status": "pending",
      "dependencies": [
        4,
        5
      ],
      "priority": "medium",
      "details": "1. Implement markdown report generator for individual repositories\n2. Create summary report generator with categorization by value and activity\n3. Add formatting for strengths, weaknesses, and recommendations\n4. Implement repository grouping by recommended action\n5. Create executive summary with portfolio overview\n6. Add report caching and timestamp comparison\n7. Implement report directory management",
      "testStrategy": "Test report generation with sample repository data. Verify markdown formatting. Test categorization logic with various repository characteristics. Validate executive summary creation. Ensure report caching works correctly with timestamp comparison."
    },
    {
      "id": 8,
      "title": "Develop action recommendation system",
      "description": "Implement the core recommendation logic to generate actionable suggestions (DELETE/ARCHIVE/EXTRACT/KEEP/PIN) with detailed reasoning.",
      "status": "pending",
      "dependencies": [
        4,
        7
      ],
      "priority": "high",
      "details": "1. Refine action recommendation algorithms based on repository characteristics\n2. Implement detailed reasoning generation for each recommendation\n3. Create priority assignment for recommendations (High/Medium/Low)\n4. Implement strength and weakness analysis based on repository data\n5. Add value assessment logic (High/Medium/Low)\n6. Create activity assessment based on commit history\n7. Implement tagging system for repository categorization",
      "testStrategy": "Test recommendation logic with various repository scenarios. Verify reasoning generation for different actions. Test priority assignment algorithm. Validate strength and weakness analysis with different repository characteristics. Ensure value and activity assessments are consistent."
    },
    {
      "id": 9,
      "title": "Implement rate limiting and error handling",
      "description": "Create robust rate limiting and error handling mechanisms for GitHub and LLM API interactions.",
      "status": "pending",
      "dependencies": [
        2,
        3
      ],
      "priority": "medium",
      "details": "1. Implement configurable rate limiters for GitHub API (default: 30 calls/minute)\n2. Create rate limiters for LLM API (default: 10 calls/minute)\n3. Implement retry mechanisms with exponential backoff\n4. Add error categorization for different failure types\n5. Create graceful degradation paths for API failures\n6. Implement detailed logging for debugging\n7. Add user-friendly error messages for common issues",
      "testStrategy": "Test rate limiting with rapid API requests. Verify retry behavior with simulated failures. Test error handling with various error scenarios. Validate logging output for different error types. Ensure graceful degradation works as expected."
    },
    {
      "id": 10,
      "title": "Set up testing framework and initial tests",
      "description": "Create a comprehensive testing framework with initial tests for core functionality.",
      "status": "pending",
      "dependencies": [
        1,
        2,
        3,
        4,
        5
      ],
      "priority": "low",
      "details": "1. Set up pytest testing framework\n2. Create mock objects for GitHub and LLM APIs\n3. Implement unit tests for domain models and services\n4. Create integration tests for application layer\n5. Implement test fixtures with sample repository data\n6. Add test coverage reporting\n7. Create CI configuration for automated testing\n8. Implement performance benchmarks for critical operations",
      "testStrategy": "Verify test coverage across all components. Ensure mocks accurately simulate API behavior. Test both success and failure paths. Validate integration tests with end-to-end scenarios. Measure performance benchmarks for baseline metrics."
    }
  ],
  "metadata": {
    "projectName": "GitHub Repository Organizer",
    "totalTasks": 10,
    "sourceFile": "scripts/prd.txt",
    "generatedAt": "2023-07-19"
  }
}